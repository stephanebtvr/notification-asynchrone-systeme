# ============================================================
# CONFIGURATION DU SERVEUR SPRING BOOT
# ============================================================
# Port sur lequel l'application écoute les requêtes HTTP
# 8080 est le port par défaut, mais on le spécifie explicitement
server.port=8080

# Nom de l'application (utile pour les logs et le monitoring)
spring.application.name=notification-service

# ============================================================
# CONFIGURATION KAFKA - PRODUCER
# ============================================================
# Adresse du broker Kafka
# localhost:9092 car Kafka tourne en Docker avec le port mappé sur l'hôte
spring.kafka.bootstrap-servers=localhost:9092

# Format de sérialisation de la clé des messages Kafka
# StringSerializer : Convertit la clé en chaîne de caractères (UTF-8)
# La clé permet de partitionner les messages (optionnel dans notre cas)
spring.kafka.producer.key-serializer=org.apache.kafka.common.serialization.StringSerializer

# Format de sérialisation de la valeur des messages
# JsonSerializer : Convertit automatiquement nos objets Java en JSON
# Pratique pour envoyer des DTOs directement sans conversion manuelle
spring.kafka.producer.value-serializer=org.springframework.kafka.support.serializer.JsonSerializer

# Niveau d'accusé de réception du broker
# all (ou -1) : Attend que TOUS les replicas aient reçu le message
# Garantit la durabilité maximale (important en production)
# Alternatives : 0 (pas d'attente), 1 (leader uniquement)
spring.kafka.producer.acks=all

# Nombre de tentatives en cas d'échec d'envoi
# 3 = retry jusqu'à 3 fois avant de lancer une exception
# Utile en cas de problème réseau temporaire
spring.kafka.producer.retries=3

# ============================================================
# CONFIGURATION KAFKA - CONSUMER
# ============================================================
# ID du groupe de consommateurs
# Tous les consumers avec le même group.id se partagent les partitions
# Ici, on a qu'un seul consumer, mais c'est une bonne pratique de le spécifier
spring.kafka.consumer.group-id=notification-group

# Point de départ de lecture si aucun offset n'est trouvé
# earliest : Lit depuis le début du topic (tous les messages historiques)
# latest : Lit uniquement les nouveaux messages après connexion
# Pour une démo, earliest permet de voir tous les messages même après redémarrage
spring.kafka.consumer.auto-offset-reset=earliest

# Format de désérialisation de la clé
spring.kafka.consumer.key-deserializer=org.apache.kafka.common.serialization.StringDeserializer

# Format de désérialisation de la valeur
# JsonDeserializer : Convertit le JSON Kafka en objet Java
spring.kafka.consumer.value-deserializer=org.springframework.kafka.support.serializer.JsonDeserializer

# Package de confiance pour la désérialisation JSON
# Sécurité : Empêche la désérialisation de classes arbitraires
# * = autorise tous les packages (OK pour démo, restreindre en prod)
spring.kafka.consumer.properties.spring.json.trusted.packages=*

# Auto-commit des offsets
# true : Kafka marque automatiquement les messages comme lus
# false : Commit manuel (plus de contrôle mais plus complexe)
spring.kafka.consumer.enable-auto-commit=true

# Intervalle d'auto-commit (millisecondes)
# Kafka commit les offsets toutes les 1000ms (1 seconde)
spring.kafka.consumer.auto-commit-interval=1000

# ============================================================
# CONFIGURATION KAFKA - TOPIC
# ============================================================
# Nom du topic utilisé pour les notifications
# On le définit ici pour centraliser la config (évite les strings magiques)
kafka.topic.notifications=notifications-topic

# ============================================================
# CONFIGURATION CORS (Cross-Origin Resource Sharing)
# ============================================================
# Permet au frontend Angular (qui tourne sur un port différent) 
# d'appeler notre API sans être bloqué par le navigateur
# En production, restreindre à l'origine du frontend uniquement
spring.web.cors.allowed-origins=http://localhost:4200,*
spring.web.cors.allowed-methods=GET,POST,PUT,DELETE,OPTIONS
spring.web.cors.allowed-headers=*
spring.web.cors.allow-credentials=true
spring.web.cors.max-age=3600
# ============================================================
# CONFIGURATION DES LOGS
# ============================================================
# Niveau de log pour notre application
logging.level.com.demo.notification=INFO

# Niveau de log pour Spring Kafka (utile pour déboguer)
# DEBUG affiche les détails des envois/réceptions
# INFO en production pour éviter trop de logs
logging.level.org.springframework.kafka=INFO

# Niveau de log pour Kafka client
logging.level.org.apache.kafka=WARN

# ============================================================
# CONFIGURATION WEBSOCKET
# ============================================================
# Endpoint STOMP pour la connexion WebSocket
# Le frontend se connectera à ws://localhost:8080/ws
websocket.endpoint=/ws

# Préfixe des destinations pour les messages STOMP
# Les clients s'abonneront à /topic/notifications
websocket.topic-prefix=/topic

# Destination spécifique pour les notifications
websocket.notification-destination=/topic/notifications
